<!DOCTYPE html>
<html lang="en">
<head>
  <title>activist.js design</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" rel="stylesheet">
</head>
<body class="container">
  <header>
    <h1>
      Activist.js: Design Doc
    </h1>
    <h4>
      <small>
        Will Scott (willscott@gmail.com)
      </small>
      <small>
        <a href="https://github.com/willscott/activist/issues">
          Discussion
        </a>
      </small>
    </h4>
  </header>
  <section>
    <h2>Overview</h2>
    <p class="lead">
      Censorship is currently seen as a user problem. But, there are meaningful
      mitigation strategies that publishers can unilaterally deploy.
      Financial and reputation benefits have supported DDOS mitigation;
      why not censorship resistance?
    </p>
    <h3>Strategy</h3>
    <p>
      There are two main mechanisms available to a publisher to
      disincentivize network interference. The first is collateral damage,
      forcing a censor to block inocuous, valuable content in order
      to fully block the publisher. In activist.js, this collateral damage
      covers all participants in the system, along with the mechanism for
      user-to-user video chat. The second mechanism for disincentivization is
      to cause users to see more objectionable content in the event of
      interference. In activist.js, this is done by educating users about
      how to circumvent censorship as a response to interference.
    </p>
    <h3>Goals</h3>
    <dl class="dl-horizontal">
      <dt>Users</dt>
      <dd>Users should not notice that mitigation is in place until censorship
          occurs. At that point, they should be offered alternative mechanisms
          to access desired content, or ideally content should continue to be
          served despite network interference.
      </dd>
      <dt>Publishers</dt>
      <dd>Nontechnical publishers should be able to apply mitigation to their
          content. Mitigation should be as close to a single script tag as
          possible, and not require changes to publisher infrastructure, or
          frequent redeployment.
      </dd>
      <dt>Censors</dt>
      <dd>Censors should be discouraged from blocking access to participating
          publishers through both technical and social means. Technically, it
          should be difficult to to prevent previous visitors from continuing
          to access a publishers content, and socially it should be worrisome
          that blocking will educate users on how to effectively circumvent
          network interference.
      </dd>
    </dl>
    <h3>Implementation</h3>
    <p>
      Using existing web APIs, participating sites will cache scripts to run
      in the event that they become inaccessable. These scripts could, as
      an example:
    </p>
    <ul>
      <li>Deliver existing circumvention tools like Tor</li>
      <li>Retrieve content through proxy indirection</li>
      <li>Retrieve content through other clients</li>
    </ul>
    <p>
      The goal is to deliver activist.js as a static javascript library for
      publishers. It will make it simple to get circumvention tools
      when you need them, by proactivly downloading them to your computer.
    </p>
  </section>
  <section>
    <h2>Technical Objectives</h2>
    <ol>
      <li>Invisible
        <ol>
          <li>No page layout change or rendering delay</li>
          <li>No infrastructure / server requirement from publishers</li>
          <li>Deniability of circumvention intent for users</li>
        </ol>
      </li>
      <li>Scalable
        <ol>
          <li>More publishers produce more collateral damage</li>
          <li>No single blockable entity</li>
        </ol>
      </li>
      <li>Private
        <ol>
          <li>Full list of participating sites should not be available</li>
          <li>Identification of other clients should not be possible</li>
        </ol>
      </li>
    </ol>
  </section>
  <section>
    <h2>Narrative</h2>
    A publisher will install activist.js via a code change like:
    <pre>
&lt;html <b>manifest='cache.manifest'</b>&gt;
  &lt;head&gt;
    <b>&lt;script type='text/javascript' src='activist.js'&gt;&lt;/script&gt;</b></pre>
    <p>
      Once in place, clients visiting the site will cache an appropriate
      circumvention binary and scripts, in case the site subsequently
      becomes unavailable.
    </p>
    <p>
      The initial version of activist.js will focus on providing access to the Tor Browser Bundle.
    </p>
    <p>
      On the first visit, activist.js will retrieve a set of ~5 other domains which also run the library, and load 5MB sections of the current bundle (a ~25MB binary) on each one (this is due to per-domain browser storage limits).  To do this, it will load iframes for those domains, and connect to the other instances. All participating domains will have the script and appcache setup, raising the probability that the downloaded content will remain accessible in the event of interference affecting multiple domains.
    </p>
    <p>
      If the domain is subsequently blocked, activist.js will prompt the user to use TorBrowser to get access to the content. User confirmation allows the page to reassemble the cached data into a single file for installation.
    </p>
  </section>
  <section>
    <h2>Activist.js Architecture</h2>
    <p>
      activist.js is structured as four components
    </p>
    <dl>
      <dt>Liveness</dt>
      <dd>
        Determines current network state, and in particular if there is
        blocking of the current domain while other network activity is
        possible.
       </dd>
       <dt>Cache</dt>
       <dd>
         Fetches appropriate content and stores it in browser storage.
         Coordinates with other active domains to shard binaries too large
         to fit in a single cache.
       </dd>
       <dt>Coordinator</dt>
       <dd>
         Coordinates, and discovers activist.js enabled domains.
         Attempt signaling in the presence of infrastructure blocking.
       </dd>
       <dt>Interface</dt>
       <dd>
         Communicates blocking to the user, and offers mitigation strategies.
       </dd>
    </dl>
    <h3>Components</h3>
    <h4>Liveness</h4>
    <p>
      Determining the state of internet connection can be done by looking at
      navigator.onLine (which detects general connectivity) in tandem with
      success of XHR requests to the local domain, and a set of 'safe' domains.
    </p>
    <h4>Cache</h4>
    <p>
      The cache will use the FileSystem API, which typically is limited to 5MB.
      A larger file can be stored by using multiple top level domains.
      To reassemble the full payload into a single url the user must approve a
      <a href='http://www.html5rocks.com/en/tutorials/file/filesystem/#toc-requesting-quota'>
        <code>requestQuota</code></a> call on one of the domains.
    </p>
    <h4>Coordinator</h4>
    <p>
      The coordinator does 2 things: Discovery of cooperating domains, and
      message passing between cooperating domains.
    </p>
    <p>
      In order to discover participating domains, we will initially use a
      private backend for coordination.  This allows us to do similar
      practical blocking mitigation as other one-hop circumvention systems.
    </p>
    <p>
      It is expected that this centralized infrastructure will be blocked
      in some locations. However, there remain a number of indirection
      channels which can be leveraged to increase the collateral damage
      associated with blocking that infrastructure - a current example of
      such collateral damage is that it is likely possible to indirect
      signaling messages through the ICE connection protocol used in
      web chat. With this indirection in place, a censor would have to
      block a significant fraction of UDP traffic, and would at least
      disrupt many general purpose video chat applications in the process
      of blocking objectionable content.
    </p>
    <p>
      For message passing, sites will add a known 'activistproxy.html' file
      on their domain to be opened in an iframe, which responds to messages
      passed by other participating domains. Domains will verify functionality
      of each other, as will the coordinator to ensure conformance to the
      protocol.
    </p>
    <h4>Interface</h4>
    <p>
      The interface will only display when a page is blocked, but needs to
      communicate to the user what has happened and what option activist.js is
      able to provide them to regain access to the content. Minimally, this
      needs to be some on-screen notification that the content they are viewing
      is state and served out of the app-cache due to network interference.
    </p>
  </section>
  <section>
    <h2>Threat Model</h2>
    <p>
      The adversary model is designed to largely express the powers of a
      state or ISP level actor. Activist.js is designed to tolerate an
      adversary with the following capabilities:
    </p>
    <ol>
      <li>Ability to block traffic using
        DNS Poisoning,
        IP Blacklist, or
        Protocol Blacklist.
      </li>
      <li>Ability to fingerprint traffic based on size and
        communication patterns.
      </li>
      <li>Unwilling to block all HTTPS Traffic.</li>
      <li>Unable to block on inspect HTTPS Traffic in realtime.</li>
    </ol>
    <h3>Attacks and Defenses</h3>
    <dl>
      <dt>Local DNS Poisoning</dt>
      <dd>
        If the local domain can't be reached, activist will be loaded by the
        cache, and can alert the user normally.
      </dd>
      <dt>Infrastructure DNS Poisoning</dt>
      <dd>
        If coordinators used by activist can't be reached, activist can attempt
        instead to initiate a WebRTC connection, using known chat server to
        alert a watching party of its presence. This works by faking the
        SIP answer to come from the well known destination, and when the
        connection can not be made directly, signaling will occur via
        intermediary stun and turn server. Upon learning of a peer, the
        coordinator can either forge packets in response, (or use a TURN
        relay) to communicate back alternative connection means.  Potentially,
        this could take the form of an unblocked client, who would only
        participate transiently in the exchange.  The complexity of this
        response is expected to develop over time as the capabilities of
        the protocols involved stabilize.
      </dd>
      <dt>IP Blocking</dt>
      <dd>
        Will Be handled in the same way as DNS Poisoning above.
      </dd>
      <dt>Blocking of other sites</dt>
      <dd>
        Potentially a smaller target can be used which fits in
        the single domain 5MB space.
      </dd>
      <dt>Crawling of participating sites</dt>
      <dd>
        short lists can be given out, including sites controlled
        by the coordinator who can track for crawling behavior.
        When crawling is distributed across many IP addresses,
        WebRTC communication against supposedly 'blocked' nodes
        can be used to help detect if new sites are really needed.
      </dd>
    </dl>
  </section>
  <a href="https://github.com/willscott/activist/blob/gh-pages/design.html"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png"></a>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-471290-12', 'activistjs.com');
    ga('send', 'pageview');

  </script>
</body>
</html>
